# Daily Progress - October 26, 2025

## Project: Decentralized Peer-to-Peer Storage System

### Detailed Technical Breakdown

This document outlines the technical implementation of the new file storage, streaming, and retrieval functionalities based on a direct analysis of the source code.

### 1. Transport Layer and Stream Handling (`p2p/tcp_transport.go`)

The TCP transport layer has been fundamentally updated to distinguish between standard RPC messages and raw data streams. This is the foundation of the file transfer mechanism.

- **Stream-Aware Read Loop (`handleConn`)**: The core connection handler, `handleConn`, now inspects every incoming `RPC` message. A new boolean field, `Stream`, has been added to the `RPC` struct.

  - If `rpc.Stream` is `false`, the message is treated as a standard RPC and sent to the `rpcChan` for processing by the `FileServer`.
  - If `rpc.Stream` is `true`, the read loop pauses its normal message decoding. It blocks using a `sync.WaitGroup` located on the `TCPPeer` struct (`peer.wg`). This allows another part of the system to take over and read a raw data stream directly from the underlying `net.Conn`. The loop only resumes after `peer.CloseStream()` is called, which signals the end of the stream.

- **`TCPPeer.CloseStream()`**: This new method on the `TCPPeer` calls `wg.Done()`, which unblocks the `handleConn` read loop, allowing it to resume processing regular RPC messages from that peer.

### 2. Server Logic and File Operations (`server.go`)

The `FileServer` orchestrates all file operations, acting as the brain for storing, requesting, and serving files across the network.

#### File Storage Flow (The `Store` method)

When a user calls `FileServer.Store(key, reader)`:

1.  **Simultaneous Write**: An `io.TeeReader` is used to split the incoming data stream (`reader`). The data is simultaneously written to the local disk via `s.store.Write()` and into an in-memory `bytes.Buffer`. This ensures the local peer has the file before broadcasting.
2.  **Broadcast Metadata**: A `Message` struct is created with its `Payload` set to `MessageStoreFile{Key: key, Size: size}`. This message, containing the file's identifier and exact size, is broadcast to all connected peers. This is a standard RPC message (`Stream: false`).
3.  **Initiate Streaming**: The server then iterates through all its peers to send the actual file content.
    - For each peer, it first sends a single byte, `p2p.IncomingStream`, to signal that a raw data stream is about to begin. The receiving peer's transport layer will see this and prepare to handle a stream.
    - Immediately after, the content of the in-memory `bytes.Buffer` is copied directly to the peer's connection using `io.Copy(peer, fileBuf)`.

#### File Retrieval Flow (The `Get` method)

When a user calls `FileServer.Get(key)`:

1.  **Local Check**: It first calls `s.store.Has(key)`. If the file exists locally, it returns a reader from the local disk immediately.
2.  **Network Request**: If the file is not found locally, it constructs a `Message` with a `MessageGetFile{Key: key}` payload and broadcasts it to the network.
3.  **Receiving the File**: The requester then waits for a peer to respond with the file stream.
    - For each peer, it anticipates a stream. It first reads the file size (`int64`) which the sender provides.
    - It then calls `s.store.Write(key, io.LimitReader(peer, fileSize))`. This reads the exact number of bytes for the file directly from the peer's connection and writes it to its own local storage.
    - Finally, it calls `peer.CloseStream()` to signal to the sender's transport layer that the stream has been fully consumed, allowing the sender's read loop for that peer to unblock.

#### Incoming Message Handling

- **`loop()` and `handleMessage()`**: The server's main `loop` listens on the transport's channel. When a message arrives, it's decoded and passed to `handleMessage`, which is a `switch` statement that routes the message based on its `Payload` type.

- **`handleMessageStoreFile(from, msg)`**: This is triggered when a peer receives the metadata broadcast from a `Store` operation.

  - It looks up the peer by its address (`from`).
  - It calls `s.store.Write(msg.Key, io.LimitReader(peer, msg.Size))`. This is the counterpart to the sender's `io.Copy`. It reads `msg.Size` bytes directly from the peer's connection and saves the file.
  - It calls `peer.CloseStream()` to unblock the sender's read loop.

- **`handleMessageGetFile(from, msg)`**: This is triggered when a peer receives a request for a file.
  - It checks if it has the file using `s.store.Has(msg.Key)`.
  - If it does, it retrieves a reader for the file from storage.
  - It sends the `p2p.IncomingStream` byte to the requester.
  - It sends the file size as an `int64` using `binary.Write`.
  - It streams the file content using `io.Copy(peer, r)`.

### 3. Storage Layer (`storage.go`)

The storage layer is designed for stream-based operations to handle large files efficiently without high memory consumption.

- **`writeStream(key, r)`**: This function takes an `io.Reader` and streams its contents directly into a file on disk. The file path is determined by the `PathTransformFunc`. It uses `os.Create` and `io.Copy`, ensuring that the entire file does not need to be held in memory during the write operation.
- **`readStream(key)`**: This function returns the file's size and an `io.ReadCloser`. By returning an interface that can be read from in chunks, it allows the server to stream the file over the network without loading the entire file into memory first.
